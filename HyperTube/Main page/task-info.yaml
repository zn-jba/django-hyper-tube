type: edu
files:
- name: tube/migrations/__init__.py
  visible: true
  learner_created: false
- name: tube/__init__.py
  visible: true
  learner_created: false
- name: hypertube/urls.py
  visible: true
  text: |
    """hypertube URL Configuration

    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/2.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path

    urlpatterns = [
        path('admin/', admin.site.urls),
    ]
  learner_created: false
- name: hypertube/wsgi.py
  visible: true
  text: |
    """
    WSGI config for hypertube project.

    It exposes the WSGI callable as a module-level variable named ``application``.

    For more information on this file, see
    https://docs.djangoproject.com/en/2.2/howto/deployment/wsgi/
    """

    import os

    from django.core.wsgi import get_wsgi_application

    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'hypertube.settings')

    application = get_wsgi_application()
  learner_created: false
- name: hypertube/__init__.py
  visible: true
  learner_created: false
- name: hypertube/settings.py
  visible: true
  text: |
    """
    Django settings for hypertube project.

    Generated by 'django-admin startproject' using Django 2.2.

    For more information on this file, see
    https://docs.djangoproject.com/en/2.2/topics/settings/

    For the full list of settings and their values, see
    https://docs.djangoproject.com/en/2.2/ref/settings/
    """

    import os

    # Build paths inside the project like this: os.path.join(BASE_DIR, ...)
    BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))


    # Quick-start development settings - unsuitable for production
    # See https://docs.djangoproject.com/en/2.2/howto/deployment/checklist/

    # SECURITY WARNING: keep the secret key used in production secret!
    SECRET_KEY = '_(l+b!c#@bx)kksgr$(zoh#!q8e8vxt4e&g&8gca_uu#h40i4z'

    # SECURITY WARNING: don't run with debug turned on in production!
    DEBUG = True

    ALLOWED_HOSTS = []


    # Application definition

    INSTALLED_APPS = [
        'django.contrib.admin',
        'django.contrib.auth',
        'django.contrib.contenttypes',
        'django.contrib.sessions',
        'django.contrib.messages',
        'django.contrib.staticfiles',
        'tube.apps.TubeConfig',
    ]

    MIDDLEWARE = [
        'django.middleware.security.SecurityMiddleware',
        'django.contrib.sessions.middleware.SessionMiddleware',
        'django.middleware.common.CommonMiddleware',
        'django.middleware.csrf.CsrfViewMiddleware',
        'django.contrib.auth.middleware.AuthenticationMiddleware',
        'django.contrib.messages.middleware.MessageMiddleware',
        'django.middleware.clickjacking.XFrameOptionsMiddleware',
    ]

    ROOT_URLCONF = 'hypertube.urls'

    TEMPLATES = [
        {
            'BACKEND': 'django.template.backends.django.DjangoTemplates',
            'DIRS': [],
            'APP_DIRS': True,
            'OPTIONS': {
                'context_processors': [
                    'django.template.context_processors.debug',
                    'django.template.context_processors.request',
                    'django.contrib.auth.context_processors.auth',
                    'django.contrib.messages.context_processors.messages',
                ],
            },
        },
    ]

    WSGI_APPLICATION = 'hypertube.wsgi.application'


    # Database
    # https://docs.djangoproject.com/en/2.2/ref/settings/#databases

    DATABASES = {
        'default': {
            'ENGINE': 'django.db.backends.sqlite3',
            'NAME': os.environ.get('HYPERSKILL_TEST_DATABASE') or os.path.join(BASE_DIR, 'db.sqlite3'),
        }
    }


    # Password validation
    # https://docs.djangoproject.com/en/2.2/ref/settings/#auth-password-validators

    AUTH_PASSWORD_VALIDATORS = [
        {
            'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
        },
        {
            'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
        },
        {
            'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
        },
        {
            'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
        },
    ]


    # Internationalization
    # https://docs.djangoproject.com/en/2.2/topics/i18n/

    LANGUAGE_CODE = 'en-us'

    LOGIN_REDIRECT_URL = '/tube/'

    TIME_ZONE = 'UTC'

    USE_I18N = True

    USE_L10N = True

    USE_TZ = True


    # Static files (CSS, JavaScript, Images)
    # https://docs.djangoproject.com/en/2.2/howto/static-files/

    STATIC_URL = '/static/'

    # MEDIA
    MEDIA_ROOT = os.environ.get('HYPERSKILL_MEDIA_ROOT') or os.path.join(BASE_DIR, 'media/')
    MEDIA_URL = '/media/'
  learner_created: false
- name: manage.py
  visible: true
  text: |
    #!/usr/bin/env python
    """Django's command-line utility for administrative tasks."""
    import os
    import sys


    def main():
        os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'hypertube.settings')
        try:
            from django.core.management import execute_from_command_line
        except ImportError as exc:
            raise ImportError(
                "Couldn't import Django. Are you sure it's installed and "
                "available on your PYTHONPATH environment variable? Did you "
                "forget to activate a virtual environment?"
            ) from exc
        execute_from_command_line(sys.argv)


    if __name__ == '__main__':
        main()
  learner_created: false
- name: tube/apps.py
  visible: true
  text: |
    from django.apps import AppConfig


    class TubeConfig(AppConfig):
        name = 'tube'
  learner_created: false
- name: tube/admin.py
  visible: true
  text: |
    from django.contrib import admin

    # Register your models here.
  learner_created: false
- name: tube/tests.py
  visible: true
  text: |
    from django.test import TestCase

    # Create your tests here.
  learner_created: false
- name: tube/views.py
  visible: true
  text: |
    from django.shortcuts import render

    # Create your views here.
  learner_created: false
- name: test/base.py
  visible: false
  text: |
    # -*- coding: utf-8 -*-
    import http.cookiejar
    import io
    import os
    import re
    import sqlite3
    import urllib

    import requests

    from hstest import CheckResult, DjangoTest, WrongAnswer


    CURRENT_DIR = os.path.dirname(os.path.abspath(__file__))
    UPLOADING_FILE_NAME = 'test_video.mp4'


    TEST_FILE_NAME = 'test/test_video.mp4'
    BACKUP_URL = 'https://stepik.org/media/attachments/lesson/415777/test_video.mp4'

    if not os.path.exists(UPLOADING_FILE_NAME):
        if not os.path.exists(TEST_FILE_NAME):
            from urllib.request import urlopen
            file_bytes = urlopen(BACKUP_URL).read()

            with open(TEST_FILE_NAME, 'wb') as f:
                f.write(file_bytes)

        from shutil import copyfile
        copyfile(TEST_FILE_NAME, UPLOADING_FILE_NAME)


    with open(UPLOADING_FILE_NAME, 'rb') as f:
        test_video_data = f.read()

    INITIAL_TAGS = [
        (1, 'sport'),
        (2, 'snake'),
        (3, 'waves'),
    ]

    INITIAL_VIDEOS = [
        (1, 'surf.mp4', 'surfing'),
        (2, 'tai.mp4', 'tai'),
    ]

    INITIAL_VIDEOTAGS = [
        (1, 1, 1),
        (2, 2, 2),
        (3, 3, 1),
    ]


    class HyperTubeTest(DjangoTest):

        use_database = True

        COMMON_LINK_PATTERN = '''<a[^>]+href=['"]([a-zA-Z\d/_]+)['"][^>]*>'''
        CSRF_PATTERN = b'<input[^>]+name="csrfmiddlewaretoken" ' \
                       b'value="(?P<csrf>\w+)"[^>]*>'
        GROUPS_FIRST_PATTERN = '<h4>.*?</h4>.*?<ul>.+?</ul>'
        GROUPS_SECOND_PATTERN = (
            '''<a[^>]+href=['"]([a-zA-Z\d/_]+)['"][^>]*>(.+?)</a>'''
        )
        H2_PATTERN = '<h2>(.+?)</h2>'
        LINK_WITH_TEXT_PATTERN = '''<a[^>]+href=['"]([a-zA-Z\d/_?=]+)['"][^>]*>(.+?)</a>'''
        PARAGRAPH_PATTERN = '<p>(.+?)</p>'
        SRC_PATTERN = '''<source[^>]+src=['"]([a-zA-Z\d/_.]+)['"][^>]*>'''
        TEXT_LINK_PATTERN = '''<a[^>]+href=['"][a-zA-Z\d/_]+['"][^>]*>(.+?)</a>'''
        cookie_jar = http.cookiejar.CookieJar()
        USERNAME = 'Test'
        PASSWORD = 'TestPassword123'
        TAG = 'testtag'
        TITLE = 'Test Video'

        def __init__(self, *args, **kwargs):
            os.environ['HYPERSKILL_MEDIA_ROOT'] = CURRENT_DIR
            file_and_dir_names = os.listdir(CURRENT_DIR)
            file_name_without_extension = UPLOADING_FILE_NAME.split('.')[0]
            for name in file_and_dir_names:
                if file_name_without_extension in name:
                    self.__delete_file(name)

            super().__init__(*args, **kwargs)

        def __delete_file(self, name):
            file_path = os.path.join(CURRENT_DIR, name)
            if name != UPLOADING_FILE_NAME and os.path.exists(file_path):
                try:
                    os.remove(file_path)
                except:
                    raise WrongAnswer(
                        f'Cannot delete file "{file_path}"\n'
                        f'Did you close it?')

        def check_create_videos(self) -> CheckResult:
            connection = sqlite3.connect(self.attach.test_database)
            cursor = connection.cursor()
            try:
                cursor.executemany(
                    'INSERT INTO tube_tag (`id`, `name`) VALUES (?, ?)',
                    INITIAL_TAGS
                )
                cursor.executemany(
                    'INSERT INTO tube_video (`id`,`file`, `title`) '
                    'VALUES (?, ?, ?)',
                    INITIAL_VIDEOS
                )
                cursor.executemany(
                    'INSERT INTO tube_videotag (`id`,`tag_id`, `video_id`) '
                    'VALUES (?, ?, ?)',
                    INITIAL_VIDEOTAGS
                )
                connection.commit()

                cursor.execute(
                    'SELECT `id`, `name` FROM tube_tag')
                tags = cursor.fetchall()

                if tags != INITIAL_TAGS:
                    return CheckResult.wrong('Check your Tag model')

                cursor.execute(
                    'SELECT `id`,`file`, `title` FROM tube_video')
                videos = cursor.fetchall()

                if videos != INITIAL_VIDEOS:
                    return CheckResult.wrong('Check your Video model')

                cursor.execute(
                    'SELECT `id`,`tag_id`, `video_id` FROM tube_videotag')
                videotags = cursor.fetchall()

                if videotags != INITIAL_VIDEOTAGS:
                    return CheckResult.wrong('Check your VideoTag model')

                return CheckResult.correct()
            except sqlite3.DatabaseError as err:
                return CheckResult.wrong(str(err))

        def check_main_header(self) -> CheckResult:
            try:
                page = self.read_page(self.get_url() + 'tube/')
            except urllib.error.URLError:
                return CheckResult.wrong(
                    'Cannot connect to the main page.'
                )

            h2_headers = re.findall(self.H2_PATTERN, page, re.S)
            h2_headers = self.__stripped_list(h2_headers)
            main_header = 'Hypertube'

            is_main_header = False
            for h2_header in h2_headers:
                if main_header in h2_header:
                    is_main_header = True
                    break

            if not is_main_header:
                return CheckResult.wrong(
                    'Main page should contain <h2> element with text "Hypertube"'
                )

            return CheckResult.correct()

        def check_main_page_login_link(self):
            login_link = '/login/'
            try:
                page = self.read_page(self.get_url() + 'tube/')
            except urllib.error.URLError:
                return CheckResult.wrong(
                    'Cannot connect to the main page.'
                )

            links_from_page = re.findall(self.COMMON_LINK_PATTERN, page, re.S)
            links_from_page = self.__stripped_list(links_from_page)

            if login_link not in links_from_page:
                return CheckResult.wrong(
                    f'Main page should contain <a> element with href {login_link}'
                )

            return CheckResult.correct()

        def check_main_page_upload_link(self):
            upload_link = '/tube/upload/'
            try:
                page = self.read_page(self.get_url() + 'tube/')
            except urllib.error.URLError:
                return CheckResult.wrong(
                    'Cannot connect to the main page.'
                )

            links_from_page = re.findall(self.COMMON_LINK_PATTERN, page, re.S)
            links_from_page = self.__stripped_list(links_from_page)

            if upload_link not in links_from_page:
                return CheckResult.wrong(
                    f'Main page should contain <a> element with href {upload_link}'
                )

            return CheckResult.correct()

        def check_main_page_video_links(self):
            connection = sqlite3.connect(self.attach.test_database)
            cursor = connection.cursor()
            try:
                cursor.execute(
                    'SELECT `id`, `title` FROM tube_video')
                videos = cursor.fetchall()
            except sqlite3.DatabaseError as err:
                return CheckResult.wrong(str(err))

            video_links_with_titles_from_db = [(f'/tube/watch/{x[0]}/',
                                                x[1]) for x in videos]

            try:
                page = self.read_page(self.get_url() + 'tube/')
            except urllib.error.URLError:
                return CheckResult.wrong(
                    'Cannot connect to the main page.'
                )

            links_from_page = re.findall(self.LINK_WITH_TEXT_PATTERN, page, re.S)
            links_from_page = self.__stripped_list_with_tuple(links_from_page)

            for video_link in video_links_with_titles_from_db:
                if video_link not in links_from_page:
                    return CheckResult.wrong(
                        'Main page should contain <a> element with href '
                        '/tube/watch/{id}/ and title as link text'
                    )

            return CheckResult.correct()

        def check_main_page_video_count(self):
            connection = sqlite3.connect(self.attach.test_database)
            cursor = connection.cursor()
            try:
                cursor.execute(
                    'SELECT count(*) FROM tube_video')
                video_count = str(cursor.fetchall()[0][0])
            except sqlite3.DatabaseError as err:
                return CheckResult.wrong(str(err))

            try:
                page = self.read_page(self.get_url() + 'tube/')
            except urllib.error.URLError:
                return CheckResult.wrong(
                    'Cannot connect to the main page.'
                )

            paragraphs_from_page = re.findall(self.PARAGRAPH_PATTERN, page, re.S)
            paragraphs_from_page = self.__stripped_list(paragraphs_from_page)

            quantity_in_paragraphs = False
            for paragraph in paragraphs_from_page:
                if video_count in paragraph:
                    quantity_in_paragraphs = True
                    break

            if not quantity_in_paragraphs:
                return CheckResult.wrong(
                    f'Main page should contain <p> element with quantity of videos'
                )

            return CheckResult.correct()

        def __stripped_list(self, list):
            return [item.strip() for item in list]

        def __stripped_list_with_tuple(self, list):
            return [(item[0].strip(), item[1].strip()) for item in list]

        def check_main_page_search(self):
            q = 'ai'
            connection = sqlite3.connect(self.attach.test_database)
            cursor = connection.cursor()
            try:
                cursor.execute(
                    f"SELECT `id`, `title` FROM tube_video WHERE title "
                    f"LIKE '%{q}%'"
                )
                visible_videos = cursor.fetchall()
            except sqlite3.DatabaseError as err:
                return CheckResult.wrong(str(err))

            visible_video_links_with_titles_from_db = \
                [(f'/tube/watch/{x[0]}/', x[1]) for x in visible_videos]

            try:
                cursor.execute(
                    f"SELECT `id`, `title` FROM tube_video WHERE title "
                    f"NOT LIKE '%{q}%'"
                )
                invisible_videos = cursor.fetchall()
            except sqlite3.DatabaseError as err:
                return CheckResult.wrong(str(err))

            invisible_video_links_with_titles_from_db = \
                [(f'/tube/watch/{x[0]}/', x[1]) for x in invisible_videos]

            try:
                page = self.read_page(self.get_url() + f'tube/?q={q}')
            except urllib.error.URLError:
                return CheckResult.wrong(
                    'Cannot connect to the main page.'
                )

            links_from_page = re.findall(self.LINK_WITH_TEXT_PATTERN, page, re.S)
            links_from_page = self.__stripped_list_with_tuple(links_from_page)

            for video_link in visible_video_links_with_titles_from_db:
                if video_link not in links_from_page:
                    return CheckResult.wrong(
                        'Main page should contain links with found videos '
                        'when searching'
                    )

            for video_link in invisible_video_links_with_titles_from_db:
                if video_link in links_from_page:
                    return CheckResult.wrong(
                        f'Main page should not contain links with unfound videos '
                        f'when searching'
                    )

            return CheckResult.correct()

        def check_main_page_tag_filtering(self):
            tag = 'sport'
            connection = sqlite3.connect(self.attach.test_database)
            cursor = connection.cursor()
            try:
                cursor.execute(
                    f"SELECT tube_video.id, tube_video.title FROM tube_video "
                    f"JOIN tube_videotag ON tube_video.id = tube_videotag.video_id "
                    f"JOIN tube_tag ON tube_videotag.tag_id = tube_tag.id "
                    f"WHERE tube_tag.name = '{tag}'"
                )
                visible_videos = cursor.fetchall()
            except sqlite3.DatabaseError as err:
                return CheckResult.wrong(str(err))

            visible_video_links_with_titles_from_db = \
                [(f'/tube/watch/{x[0]}/', x[1]) for x in visible_videos]

            try:
                cursor.execute(
                    f"SELECT tv.id, tv.title FROM tube_video tv "
                    f"WHERE NOT EXISTS (SELECT 1 FROM tube_video "
                    f"JOIN tube_videotag ON tube_video.id = tube_videotag.video_id "
                    f"JOIN tube_tag ON tube_videotag.tag_id = tube_tag.id "
                    f"WHERE tube_tag.name = '{tag}' AND tv.id = tube_video.id)"
                )
                invisible_videos = cursor.fetchall()
            except sqlite3.DatabaseError as err:
                return CheckResult.wrong(str(err))

            invisible_video_links_with_titles_from_db = \
                [(f'/tube/watch/{x[0]}/', x[1]) for x in invisible_videos]

            try:
                page = self.read_page(
                    self.get_url() + f'tube/?tag={tag}'
                )
            except urllib.error.URLError:
                return CheckResult.wrong(
                    'Cannot connect to the main page.'
                )

            links_from_page = re.findall(self.LINK_WITH_TEXT_PATTERN, page, re.S)
            links_from_page = self.__stripped_list_with_tuple(links_from_page)

            for video_link in visible_video_links_with_titles_from_db:
                if video_link not in links_from_page:
                    return CheckResult.wrong(
                        'Main page should contain links with found videos when '
                        'filtering with tags'
                    )

            for video_link in invisible_video_links_with_titles_from_db:
                if video_link in links_from_page:
                    return CheckResult.wrong(
                        'Main page should not contain links with unfound videos '
                        'when filtering with tags'
                    )

            return CheckResult.correct()

        def check_signup(self) -> CheckResult:
            opener = urllib.request.build_opener(
                urllib.request.HTTPCookieProcessor(self.cookie_jar)
            )
            try:
                response = opener.open(self.get_url() + 'signup/')
            except urllib.error.URLError:
                return CheckResult.wrong('Cannot connect to the signup page.')

            csrf_options = re.findall(
                b'<input[^>]+value="(?P<csrf>\w+)"[^>]*>', response.read()
            )
            if not csrf_options:
                return CheckResult.wrong('Missing csrf_token in the form')

            try:
                response = opener.open(
                    self.get_url() + 'signup/',
                    data=urllib.parse.urlencode({
                        'csrfmiddlewaretoken': csrf_options[0],
                        'username': self.USERNAME,
                        'password1': self.PASSWORD,
                        'password2': self.PASSWORD,
                    }).encode()
                )

                if f'login' in response.url:
                    return CheckResult.correct()
                return CheckResult.wrong('Cannot signup: problems with form')
            except urllib.error.URLError as err:
                return CheckResult.wrong(f'Cannot signup: {err.reason}')

        def check_login(self) -> CheckResult:
            opener = urllib.request.build_opener(
                urllib.request.HTTPCookieProcessor(self.cookie_jar))
            try:
                response = opener.open(self.get_url() + 'login/')
            except urllib.error.URLError:
                return CheckResult.wrong('Cannot connect to the login page.')

            csrf_options = re.findall(
                b'<input[^>]+value="(?P<csrf>\w+)"[^>]*>', response.read()
            )
            if not csrf_options:
                return CheckResult.wrong('Missing csrf_token in the form')

            try:
                response = opener.open(
                    self.get_url() + 'login/',
                    data=urllib.parse.urlencode({
                        'csrfmiddlewaretoken': csrf_options[0],
                        'username': self.USERNAME,
                        'password': self.PASSWORD,
                    }).encode(),
                )
                if 'login' not in response.url:
                    return CheckResult.correct()
                return CheckResult.wrong('Cannot login: problems with form')
            except urllib.error.URLError as err:
                return CheckResult.wrong(f'Cannot login: {err.reason}')

        def check_uploading_video(self):
            opener = urllib.request.build_opener(
                urllib.request.HTTPCookieProcessor(self.cookie_jar))
            try:
                upload_page_response = opener.open(
                    self.get_url() + 'tube/upload/')
            except urllib.error.URLError:
                return CheckResult.wrong('Cannot connect to the upload page.')

            upload_page = upload_page_response.read()

            csrf_options = re.findall(self.CSRF_PATTERN, upload_page)

            if not csrf_options:
                return CheckResult.wrong(
                    'Missing csrf_token in the upload page form')

            new_video = {
                'title': self.TITLE,
                'tags': self.TAG,
                'csrfmiddlewaretoken': csrf_options[0],
            }
            files = {'video': open(UPLOADING_FILE_NAME, 'rb')}

            upload_response = requests.post(
                self.get_url() + 'tube/upload/',
                cookies=self.cookie_jar, files=files, data=new_video
            )

            if upload_response.url != self.get_url() + 'tube/':
                return CheckResult.wrong(
                    'After uploading video handler should redirects to the /tube/ '
                    'page')

            connection = sqlite3.connect(self.attach.test_database)
            cursor = connection.cursor()
            try:
                cursor.execute(
                    f"SELECT count(*) FROM tube_video WHERE title = '{self.TITLE}'"
                )
                videos = cursor.fetchall()
            except sqlite3.DatabaseError as err:
                return CheckResult.wrong(str(err))

            if videos[0][0] != 1:
                return CheckResult.wrong(
                    'After uploading video data doesn\'t saved in database')

            return CheckResult.correct()

        def check_forbid_anonymous_upload(self) -> CheckResult:
            opener = urllib.request.build_opener()
            try:
                upload_page_response = opener.open(
                    self.get_url() + 'tube/upload/')
            except urllib.error.URLError:
                return CheckResult.wrong('Cannot connect to the upload page.')

            upload_page = upload_page_response.read()

            csrf_options = re.findall(self.CSRF_PATTERN, upload_page)
            if not csrf_options:
                return CheckResult.correct()

            title = 'Test Video'

            new_video = {
                'title': title,
                'tags': 'testtag',
                'csrfmiddlewaretoken': csrf_options[0],
            }
            files = {'video': open(UPLOADING_FILE_NAME, 'rb')}

            upload_response = requests.post(
                self.get_url() + 'tube/upload/', files=files,
                data=new_video
            )

            if upload_response.status_code != 403:
                return CheckResult.wrong(
                    'Should not allow anonymous users upload video')

            return CheckResult.correct()

        def check_upload_page_main_link(self):
            main_link = '/tube/'

            try:
                page = self.read_page(
                    self.get_url() + 'tube/upload/')
            except urllib.error.URLError:
                return CheckResult.wrong(
                    'Cannot connect to the upload page.'
                )

            links_from_page = re.findall(self.COMMON_LINK_PATTERN, page, re.S)
            links_from_page = self.__stripped_list(links_from_page)

            if main_link not in links_from_page:
                return CheckResult.wrong(
                    f'Upload page should contain <a> element with href {main_link}'
                )

            return CheckResult.correct()

        def check_watch_and_video_response(self):
            video_template_link = '/tube/{file_name}/'
            login_link = '/login/'
            main_link = '/tube/'
            try:
                watch_response = self.read_page(
                    self.get_url() + 'tube/watch/3/')
            except urllib.error.URLError:
                return CheckResult.wrong(
                    'Cannot connect to the watch page.'
                )

            links_from_page = re.findall(self.COMMON_LINK_PATTERN, watch_response,
                                         re.S)
            links_from_page = self.__stripped_list(links_from_page)

            if login_link not in links_from_page:
                return CheckResult.wrong(
                    f'Watch page should contain <a> element with href {login_link}'
                )
            if main_link not in links_from_page:
                return CheckResult.wrong(
                    f'Watch page should contain <a> element with href {main_link}'
                )

            paragraphs_from_page = re.findall(self.PARAGRAPH_PATTERN,
                                              watch_response, re.S)
            paragraphs_from_page = self.__stripped_list(paragraphs_from_page)
            if self.TITLE not in paragraphs_from_page:
                return CheckResult.wrong(
                    f'Watch page should contain <p> element with the video title'
                )

            links_with_text_from_page = re.findall(
                self.LINK_WITH_TEXT_PATTERN, watch_response, re.S)
            links_with_text_from_page = self.__stripped_list_with_tuple(
                links_with_text_from_page)

            video_link_with_text = (f'/tube/?tag={self.TAG}', f'#{self.TAG}')
            if video_link_with_text not in links_with_text_from_page:
                return CheckResult.wrong(
                    'Watch page should contain <a> element with href to '
                    '/tube/?tag={tag} filter and #{tag} as link text, where '
                    'tag is your tag name'
                )

            src_from_page = re.findall(self.SRC_PATTERN, watch_response, re.S)
            src_from_page = self.__stripped_list(src_from_page)
            video_link = None

            for src in src_from_page:
                if UPLOADING_FILE_NAME.split('.')[0] in src:
                    if src.endswith('/'):
                        src = src[:-1]
                    video_link = src
                    break

            if not video_link:
                return CheckResult.wrong(
                    f'Watch page should contain <source> element with src '
                    f'{video_template_link}'
                )
            file_name_to_delete = video_link.split('/')[-1]

            video_response = requests.get(
                f'{self.get_url()}{video_link[1:]}/')

            required_header = {'Accept-Ranges': 'bytes'}

            if video_response.headers.get('Accept-Ranges') != 'bytes':
                self.__delete_file(file_name_to_delete)
                return CheckResult.wrong(
                    f'Video response should contain header {required_header}'
                )

            if video_response.headers.get('Content-Type') != 'video/mp4':
                self.__delete_file(file_name_to_delete)
                return CheckResult.wrong(
                    f'Video response should contain Content-Type header, '
                    f'e.g. Content-Type: video/mp4 for mp4 video'
                )

            response_file_bytes = io.BytesIO()
            for chunk in video_response.iter_content(chunk_size=1024):
                response_file_bytes.write(chunk)

            if response_file_bytes.getvalue() != test_video_data:
                self.__delete_file(file_name_to_delete)
                return CheckResult.wrong(
                    'Video response should contain uploaded file in bytes'
                )

            self.__delete_file(file_name_to_delete)
            return CheckResult.correct()
  learner_created: false
- name: tests.py
  visible: false
  text: |
    # -*- coding: utf-8 -*-
    from hstest import dynamic_test

    from test.base import HyperTubeTest


    class HyperTubeTestRunner(HyperTubeTest):

        funcs = [
            # 1 task
            HyperTubeTest.check_create_videos,
            # 2 task
            HyperTubeTest.check_main_header,
            HyperTubeTest.check_main_page_login_link,
            HyperTubeTest.check_main_page_upload_link,
            HyperTubeTest.check_main_page_video_links,
            HyperTubeTest.check_main_page_video_count,
        ]

        @dynamic_test(data=funcs)
        def test(self, func):
            return func(self)


    if __name__ == '__main__':
        HyperTubeTestRunner().run_tests()
  learner_created: false
- name: test/test_video.mp4
  visible: false
  text: ftypisomisomiso2avc1mp41freeDRmdatEHx264+core160r300033f9e14+H264/MPEG+4AVCcodec+Copyleft2003+2020+http//wwwvideolanorg/x264html+optionscaba
  learner_created: false
- name: test/__init__.py
  visible: false
  learner_created: false
- name: tube/models/video_tag.py
  visible: true
  text: |
    from django.db import models

    from .tag import Tag
    from .video import Video


    class VideoTag(models.Model):
        tag = models.ForeignKey(Tag, related_name="tag", on_delete=models.CASCADE)
        video = models.ForeignKey(Video, related_name="video", on_delete=models.CASCADE)
  learner_created: true
- name: tube/migrations/0001_initial.py
  visible: true
  text: |
    # Generated by Django 2.2 on 2021-09-13 10:59

    from django.db import migrations, models
    import django.db.models.deletion


    class Migration(migrations.Migration):

        initial = True

        dependencies = [
        ]

        operations = [
            migrations.CreateModel(
                name='Tag',
                fields=[
                    ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                    ('name', models.CharField(max_length=255)),
                ],
            ),
            migrations.CreateModel(
                name='Video',
                fields=[
                    ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                    ('title', models.CharField(max_length=255)),
                    ('file', models.FileField(upload_to='')),
                ],
            ),
            migrations.CreateModel(
                name='VideoTag',
                fields=[
                    ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                    ('tag', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='tag', to='tube.Tag')),
                    ('video', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='video', to='tube.Video')),
                ],
            ),
        ]
  learner_created: true
- name: tube/models/video.py
  visible: true
  text: |
    from django.db import models


    class Video(models.Model):
        title = models.CharField(max_length=255)
        file = models.FileField()
  learner_created: true
- name: tube/models/tag.py
  visible: true
  text: |
    from django.db import models


    class Tag(models.Model):
        name = models.CharField(max_length=255)
  learner_created: true
- name: tube/models/__init__.py
  visible: true
  text: |
    from .tag import Tag
    from .video import Video
    from .video_tag import VideoTag
  learner_created: true
- name: tube/urls.py
  visible: true
  learner_created: true
- name: tube/templates/tube/upload.html
  visible: true
  learner_created: true
- name: tube/templates/tube/login.html
  visible: true
  learner_created: true
- name: test_video.mp4
  visible: true
  learner_created: true
feedback_link: https://hyperskill.org/projects/131/stages/698/implement#comment
status: Solved
feedback:
  message: Congratulations!
  time: Mon, 13 Sep 2021 12:39:15 UTC
record: 2
